/*
 * 核心目的: 
 * 该脚本追踪 io_uring_enter 系统调用，统计每次 Syscall 提交的 SQE (Submission Queue Entry) 数量。
 * 用于验证 Phase 6 Group Commit (组提交) 机制是否生效，以及评估 Batching 策略的效率。
 *
 * 使用方法: 
 * 1. 启动压测程序: ./tests/bench_titankv_standalone
 * 2. 另开终端运行: sudo ./tools/trace_uring.bt
 *
 * 关键指标解读:
 * - @submit_batch_size: 提交批次大小的直方图。
 *   - [0, 1) 区间计数高: 说明系统调用频繁，每次只提交 1 个 IO (Group Commit 可能未生效，或者是单次大 IO 提交)。
 *   - 在 TitanKV Group Commit 场景下，理想情况是绝大多数 io_uring_enter 的 to_submit 为 1 (因为我们将 N 个请求合并成了 1 个大 Buffer 的写操作)。
 *   - 对比视角: 如果没有 Group Commit，每写入 1 个 KV 就调用一次 uring_enter，syscall 数量会爆炸。
 * - @calls: 总系统调用次数。
 *   - 验证点: 比较 (@calls * BatchSize) 与 (Total Ops)。比值越低，说明系统调用合并率越高。
 *
 * 案例: TitanKV Group Commit 验证
 * [未优化前]: 处理 50,000 个请求，产生 ~50,000 次系统调用。
 * [优化后]: 处理 50,000 个请求，仅产生 ~1,000 次系统调用。
 * 结论: 成功减少了 98% 的用户态/内核态切换开销 (Context Switch Overhead)。
 */

#!/usr/bin/env bpftrace

BEGIN
{
    printf("Tracing io_uring_enter syscalls... Hit Ctrl-C to end.\n");
}

/*
 * syscall: io_uring_enter(int fd, unsigned int to_submit, 
 *                         unsigned int min_complete, unsigned int flags, ...)
 * args->to_submit: 本次提交了多少个请求
 */
tracepoint:syscalls:sys_enter_io_uring_enter
/comm == "bench_titankv_s"/
{
    @submit_batch_size = lhist(args->to_submit, 0, 256, 16);
    @calls = count();
}

END
{
    printf("\n[Results]\n");
}