# 优化：Fixed Files (固定文件注册)

## 1. 背景与挑战
在 TitanKV 达到 10w 级 IOPS 后，通过 **perf** 采样发现了一个反直觉的现象：尽管使用了异步的 io_uring，但内核态入口函数 do_syscall_64 的 **CPU 占比依然接近 50%**。

**深度分析：**
在标准异步 IO 流程中，内核处理每个请求必须执行两个动作：

**文件描述符查找** ：根据用户态传来的整数 FD，去进程文件表中查找对应的 struct file 对象。
**原子引用计数** ：内核必须执行 fget/fput 以保证 IO 期间文件不被关闭。

**痛点**：在高频 IO 场景下，对同一个 Log 文件的原子引用计数操作会导致多个 CPU 核心频繁争抢同一个缓存行，触发大量的 MESI 协议一致性流量，这成为了阻塞吞吐量的“行政门槛”。

## 2. 方案：内核态文件对象常驻化
引入 io_uring 的 **Fixed Files (固定文件注册)** 机制，旨在实现全路径 **“零查找、零原子计数”**。
核心动作：
初始化阶段：通过 io_uring_register_files 将 Log 文件的 FD 预注册到内核 ring 的私有数组中。
提交阶段：在 SQE 请求中设置 IOSQE_FIXED_FILE 标志，直接通过数组索引（Index）提交。
效果：内核直接在 ring 的生命周期内持有文件引用，彻底消灭了热路径上的 fget/fput 原子开销。

## 3. 基准测试结果
测试场景：100,000 次随机写入，4 核虚拟机，开启 Group Commit。
